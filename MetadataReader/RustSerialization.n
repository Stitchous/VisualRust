using Nemerle;
using Nemerle.Collections;
using Nemerle.Text;
using Nemerle.Utility;

using System;
using System.Collections.Generic;
using System.Linq;

using System.Reflection;

namespace MetadataReader
{
    public module RustSerialization
    {
        public Deserialize[T](buffer : array[byte], offset : int) : T * int where T : new()
        {
            def (obj, offset) = Deserialize(typeof(T), buffer, offset);
            (obj :> T, offset)
        }
       
       private Convert[T](inp : int -> T*int) : int -> object*int
       {
            i => {  def (o,p) = inp(i); (o,p) };
       }

        public Deserialize(type : Type, buffer : array[byte], offset : int) : object*int 
        {
            def result = Activator.CreateInstance(type);

            def GetReader(type : Type) : int -> object*int
            {
                | type when type.Equals(typeof(string))           => Convert(DeserializeString(buffer, _))
                | type when type.Equals(typeof(System.UInt64))    => Convert(ReadUInt64(buffer, _))
                | type when type.IsClass                          
                | type when type.IsValueType && !type.IsPrimitive => Deserialize(type, buffer, _)
                | _ => throw NotSupportedException()
            }

            def DeserializeFields(fields, offset) 
            {
                match(fields)
                {
                    | field :: tail =>
                        def reader = GetReader(field.FieldType);
                        def (value, offset) = reader(offset);
                        field.SetValue(result, value);
                        DeserializeFields(tail, offset);
                    | _            => offset
                }
            }
            
            def fields = type.GetFields(BindingFlags.Instance | BindingFlags.Public %|
                                            BindingFlags.NonPublic | BindingFlags.DeclaredOnly) |> NList.ToList;
                        
            (result, DeserializeFields(fields, offset))
        }

        

        public DeserializeString(buffer : array[byte], offset : int) : string * int
        {
            def (ulen, position) = ReadUInt(buffer, offset);
            def len = ulen :> int;
            def value = System.Text.Encoding.UTF8.GetString(buffer, position, len);
            
            (value, position + len)
        }

        private ReadUInt(buffer : array[byte], offset : int) : uint * int
        {
            def (value, offset) = ReadLeb128UInt(buffer, offset);
            (value :> uint, offset)
        }

        private ReadUInt64(buffer : array[byte], offset : int) : ulong * int
        {
            ReadLeb128UInt(buffer, offset)
        }

        private ReadLeb128UInt(buffer : array[byte], offset : int) : ulong*int
        {
            def Read(offset, tmpResult : ulong, shift)
            {
                def byte = buffer[offset];
                def result = tmpResult | ((byte &0x7F) << shift);

                if (byte %&& 0x80)
                    Read(offset + 1, result, shift + 7)
                else 
                    (result, offset + 1)
            }

            Read(offset, 0, 0)
        }
    }
}
